function varargout = plotter(varargin)
% PLOTTER M-file for plotter.fig
%      PLOTTER, by itself, creates a new PLOTTER or raises the existing
%      singleton*.
%
%      H = PLOTTER returns the handle to a new PLOTTER or the handle to
%      the existing singleton*.
%
%      PLOTTER('Property','Value',...) creates a new PLOTTER using the
%      given property value pairs. Unrecognized properties are passed via
%      varargin to plotter_OpeningFcn.  This calling syntax produces a
%      warning when there is an existing singleton*.
%
%      PLOTTER('CALLBACK') and PLOTTER('CALLBACK',hObject,...) call the
%      local function named CALLBACK in PLOTTER.M with the given input
%      arguments.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES
% Edit the above text to modify the response to help plotter
% Last Modified by GUIDE v2.5 17-Jul-2003 10:05:33

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @plotter_OpeningFcn, ...
                   'gui_OutputFcn',  @plotter_OutputFcn, ...
                   'gui_LayoutFcn',  [], ...
                   'gui_Callback',   []);
if nargin & isstr(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before plotter is made visible.
function plotter_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   unrecognized PropertyName/PropertyValue pairs from the
%            command line (see VARARGIN)
% Choose default command line output for plotter
handles.output = hObject;

% set defaults/parameters...
handles.sim_path = '..\..\output\river\daily\hydlu\'; % search path for simulated data (parameter).
handles.obs_path = '..\data\observed\'; % search path for observed data (parameter).
handles.default_mindate = '10/1/1982';
handles.default_maxdate = '9/30/2002';
guidata(hObject, handles);

% initialize variables...
handles.catcode = 'example';
handles.catcode_title = 'example'; % catcode w/o under-scores for title.
handles.data_type = 'flow';
handles.mindate = handles.default_mindate;
handles.maxdate = handles.default_maxdate;

handles.hide_precip = 0; % time-series plot parameters.
handles.hide_obs_ts = 0;
handles.logscale_ts = 0;

handles.hide_regress = 0; % sim vs. obs plot parameters.
handles.hide_yxline = 0;

handles.hide_obs_cum = 0; % cumulative frequency plot parameters.
handles.dont_log_cum = 0;

handles.plot_data = [NaN,NaN,NaN,NaN];

guidata(hObject, handles); % update handles structure

% UIWAIT makes plotter wait for user response (see UIRESUME)
% uiwait(handles.figure1);


% --- Outputs from this function are returned to the command line.
function varargout = plotter_OutputFcn(hObject, eventdata, handles)
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


% --- Executes on mouse press over figure background.
function figure1_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to figure1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


%================ CURRENT SEGEMENT SPECIFICATION BOX ===============
% --- Executes during object creation, after setting all properties.
function catcode_edit_CreateFcn(hObject, eventdata, handles)
% hObject    handle to catcode_edit (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called
% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end
function catcode_edit_Callback(hObject, eventdata, handles)
% hObject    handle to catcode_edit (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Hints: get(hObject,'String') returns contents of catcode_edit as text
%        str2double(get(hObject,'String')) returns contents of catcode_edit as a double
catcode = get(hObject,'String'); % get and store catcode (root of filename to process).
catcode_title = catcode;
% catcode_title(findstr(catcode,'_') = ' '

handles.catcode = catcode;
handles.catcode_title = catcode_title;
guidata(hObject,handles);


%=================== DATA TYPE SPECIFICATION BOX ====================
% --- Executes during object creation, after setting all properties.
function data_type_popupmenu_CreateFcn(hObject, eventdata, handles)
% hObject    handle to data_type_popupmenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called
% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end
% --- Executes on selection change in data_type_popupmenu.
function data_type_popupmenu_Callback(hObject, eventdata, handles)
% hObject    handle to data_type_popupmenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Hints: contents = get(hObject,'String') returns data_type_popupmenu contents as cell array
%        contents{get(hObject,'Value')} returns selected item from data_type_popupmenu
contents = get(hObject,'String');
data_type = contents{get(hObject,'Value')};
data_type = data_type(1: findstr(data_type,' ')-1 ); % reassign long data type name in menu to abbreviation.
handles.data_type = data_type;
guidata(hObject,handles);


%========================= MIN DATE SPECIFICATION BOX =======================
% --- Executes during object creation, after setting all properties.
function mindate_edit_CreateFcn(hObject, eventdata, handles)
% hObject    handle to mindate_edit (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called
% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end
function mindate_edit_Callback(hObject, eventdata, handles)
% hObject    handle to mindate_edit (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Hints: get(hObject,'String') returns contents of mindate_edit as text
%        str2double(get(hObject,'String')) returns contents of mindate_edit as a double
temp = get(hObject,'String'); % get and store the minimum plot date (mm/dd/yyyy).
err = check_date(temp); % test for valid date.
if err ~= 0
    set(hObject, 'String', handles.mindate); % resets value in gui text window.
else
    handles.mindate = temp; % date OK - store.
end
guidata(hObject,handles);


%========================= MAX DATE SPECIFICATION BOX =======================
% --- Executes during object creation, after setting all properties.
function maxdate_edit_CreateFcn(hObject, eventdata, handles)
% hObject    handle to maxdate_edit (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called
% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc
    set(hObject,'BackgroundColor','white');
else
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));
end
function maxdate_edit_Callback(hObject, eventdata, handles)
% hObject    handle to maxdate_edit (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Hints: get(hObject,'String') returns contents of maxdate_edit as text
%        str2double(get(hObject,'String')) returns contents of maxdate_edit as a double
temp = get(hObject,'String'); % get and store the maximum plot date (mm/dd/yyyy).
err = check_date(temp); % test for valid date.
if err ~= 0
    set(hObject, 'String', handles.maxdate); % resets value in gui text window.
else
    handles.maxdate = temp; % date OK - store.
end
guidata(hObject,handles);


%=================== HIDE OBSERVED TIME-SERIES ===================
% --- Executes on button press in timeseries_obs_checkbox.
function timeseries_obs_checkbox_Callback(hObject, eventdata, handles)
% hObject    handle to timeseries_obs_checkbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Hint: get(hObject,'Value') returns toggle state of timeseries_obs_checkbox
hide_obs_ts = get(hObject,'Value'); % get and store the hide obs. time-series plot option.
if hide_obs_ts == 0 % show obs data line.
    set(findobj(handles.timeseries_axes,'Type','line','Color',[0 0.5 0]), 'Visible','on');
else % hide obs data line.
    set(findobj(handles.timeseries_axes,'Type','line','Color',[0 0.5 0]), 'Visible','off');
end
handles.hide_obs_ts = hide_obs_ts;
guidata(hObject,handles);


%======= HIDE PRECIP INVERTED BAR PLOT ON TIME-SERIES =================
% --- Executes on button press in timeseries_precip_checkbox.
function timeseries_precip_checkbox_Callback(hObject, eventdata, handles)
% hObject    handle to timeseries_precip_checkbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Hint: get(hObject,'Value') returns toggle state of timeseries_precip_checkbox
hide_precip = get(hObject,'Value'); % get and store the show precip time-series plot option.
if hide_precip == 0 % show inverted precip bars.
    set(findobj(handles.precip_axes,'FaceColor','b'),'Visible','on');
else % hide precip bars.
    set(findobj(handles.precip_axes, 'FaceColor','b'), 'Visible','off');
end
handles.hide_precip = hide_precip;
guidata(hObject,handles);


%========== USE LOG Y-SCALE FOR TIME-SERIES PLOT ==============
% --- Executes on button press in log_scale_checkbox.
function log_scale_checkbox_Callback(hObject, eventdata, handles)
% hObject    handle to log_scale_checkbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Hint: get(hObject,'Value') returns toggle state of log_scale_checkbox
logscale_ts = get(hObject,'Value'); % get and store the log y-scale time-series plot option.
if logscale_ts ~= 0 % use log Y-scale.
    set(handles.timeseries_axes,'Yscale','log');
else % use linear scale.
    set(handles.timeseries_axes,'Yscale','linear');
end
handles.logscale_ts = logscale_ts;
guidata(hObject,handles);


%========= LAUNCH SEPARATE WINDOW FOR TIME-SERIES PLOT ===========
% --- Executes on button press in examine_timeseries_pushbutton.
function examine_timeseries_pushbutton_Callback(hObject, eventdata, handles)
% hObject    handle to examine_timeseries_pushbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
figure; % create separate figure window.
axes1 = axes;
axes2 = axes;
plot_ts(handles,axes1,axes2);
% zoom tool in separate figure only works on one axis at a time.
% need to hide precip and activate time-series axes.
set(findobj(axes2, 'FaceColor',[0 0.4 0]), 'Visible','off');
set(gca,'YTick',[]);
ylabel(' ');
axes(axes1); % activate time-series axes.


%========== HIDE BEST-FIT LINE IN SIM VS. OBS PLOT ================
% --- Executes on button press in simobs_regress_checkbox.
function simobs_regress_checkbox_Callback(hObject, eventdata, handles)
% hObject    handle to simobs_regress_checkbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Hint: get(hObject,'Value') returns toggle state of simobs_regress_checkbox
hide_regress = get(hObject,'Value'); % get and store the hide regression line sim vs. obs plot option.
if hide_regress == 0 % show regression line.
    set(findobj(handles.simobs_axes,'Type','line','Color','r'), 'Visible','on');
else % hide obs data line.
    set(findobj(handles.simobs_axes,'Type','line','Color','r'), 'Visible','off');
end
handles.hide_regress = hide_regress;
guidata(hObject,handles);


%======= HIDE Y=X LINE IN SIM VS. OBS PLOT =====================
% --- Executes on button press in hide_yx_checkbox.
function hide_yx_checkbox_Callback(hObject, eventdata, handles)
% hObject    handle to hide_yx_checkbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Hint: get(hObject,'Value') returns toggle state of hide_yx_checkbox
hide_yxline = get(hObject,'Value'); % get and store the hide y=x line sim vs. obs plot option.
if hide_yxline == 0 % plot y = x line.
    set(findobj(handles.simobs_axes,'Type','line','Color',[0 0.5 0]), 'Visible','on');
else % hide obs data line.
    set(findobj(handles.simobs_axes,'Type','line','Color',[0 0.5 0]), 'Visible','off');
end
handles.hide_yxline = hide_yxline;
guidata(hObject,handles);


%=============== HIDE OBSERVED CUMULATIVE PLOT =====================
% --- Executes on button press in cumprob_obs_checkbox.
function cumprob_obs_checkbox_Callback(hObject, eventdata, handles)
% hObject    handle to cumprob_obs_checkbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Hint: get(hObject,'Value') returns toggle state of cumprob_obs_checkbox
hide_obs_cum = get(hObject,'Value'); % get and store the hide observed cumulative plot option.
if hide_obs_cum == 0 % show obs line.
    set(findobj(handles.cumprob_axes,'Type','line','Color',[0 0.5 0]), 'Visible','on');
else % hide obs line.
    set(findobj(handles.cumprob_axes,'Type','line','Color',[0 0.5 0]), 'Visible','off');
end
handles.hide_obs_cum = hide_obs_cum;
guidata(hObject,handles);


%========== PLOT LOG DATA FOR CUMULATIVE PLOT ==================
% --- Executes on button press in plot_log_data_checkbox.
function plot_log_data_checkbox_Callback(hObject, eventdata, handles)
% hObject    handle to plot_log_data_checkbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Hint: get(hObject,'Value') returns toggle state of plot_log_data_checkbox
dont_log_cum = get(hObject,'Value'); % get and store the don't log data cumulative plot option.
if dont_log_cum ~= 0 % use log X-scale.
    set(handles.cumprob_axes,'Xscale','log');
else % use linear scale.
    set(handles.cumprob_axes,'Xscale','linear');
end
handles.dont_log_cum = dont_log_cum;
guidata(hObject,handles);


%===================== UPDATE PLOTS PUSHBUTTON ==========================
% ALL DATA ARE READ WITH THIS BUTTON PUSH
% ALL PLOTS ARE GENERATED WITH THIS BUTTON PUSH
% ALL STATS ARE COMPUTED WITH THIS BUTTON PUSH
%
% --- Executes on button press in update_plots_pushbutton.
function update_plots_pushbutton_Callback(hObject, eventdata, handles)
% hObject    handle to update_plots_pushbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% clear plots and stats...
clear_plots(handles); % clear all plot windows.
clear_stats(handles); % clear all stat windows.

% check that mindate < maxdate...
if datenum(handles.mindate) >= datenum(handles.maxdate)
    uiwait(errordlg('"max date" must be greater than the "min date".','Error','modal'));
    % reset date values to defaults and abort...
    set(handles.mindate_edit, 'String', handles.default_mindate);
    set(handles.maxdate_edit, 'String', handles.default_maxdate);
    handles.mindate = handles.default_mindate;
    handles.maxdate = handles.default_maxdate;
    guidata(hObject,handles);
    return;
end

% read data according to specifications...
[plot_data, err] = get_data(handles);
if err ~= 0
    return;
end
% store and save data set in GUI data structure...
handles.plot_data = plot_data;
guidata(hObject,handles);

% create time-series plot...
plot_ts(handles,handles.timeseries_axes,handles.precip_axes);

% create sim vs. obs plot...
plot_sim_obs(handles,handles.simobs_axes);

% create cumulative dist. plot...
plot_cum(handles,handles.cumprob_axes);

% compute stats and update GUI stats text-boxes...
calc_stats(handles);


%========================= PRINT CONTROLS =======================
% --- Executes on button press in print_timeseries_pushbutton.
function print_timeseries_pushbutton_Callback(hObject, eventdata, handles)
% hObject    handle to print_timeseries_pushbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
h = gcf; % save plotter figure handle.
figure; % create temporary, separate figure window for printing.
axes1 = axes; % create time-series axes on new figure.
axes2 = axes; % create precip axes on new figure.
plot_ts(handles,axes1,axes2);
set(findobj(axes1,'Type','line','Color','r'), 'LineStyle',':'); % set sim line to dotted for print.
% set(findobj(axes1,'Type','line','Color',[0 0.5 0]), 'LineWidth',2.5); % set obs line to heavier width for print.
set(gcf,'PaperOrientation','landscape', 'PaperPosition',[0.5,0.5,10,7.5]); % set up page format: landscape with 0.5inch margins.
print; % print figure.
close(gcf); % close temporary figure.
figure(h); % set plotter as active figure.

% --- Executes on button press in print_simobs_pushbutton.
function print_simobs_pushbutton_Callback(hObject, eventdata, handles)
% hObject    handle to print_simobs_pushbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
h = gcf; % save plotter figure handle.
figure; % create temporary, separate figure window for printing.
axes1 = axes; % create axes on new figure.
plot_sim_obs(handles,axes1);
set(gcf,'PaperOrientation','portrait', 'PaperPosition',[0.5,1.75,7.5,7.5]); % set up page format: portrait with 7.5inch centered figure.
print; % print figure.
close(gcf); % close temporary figure.
figure(h); % set plotter as active figure.

% --- Executes on button press in print_cumprob_pushbutton.
function print_cumprob_pushbutton_Callback(hObject, eventdata, handles)
% hObject    handle to print_cumprob_pushbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
h = gcf; % save plotter figure handle.
figure; % create temporary, separate figure window for printing.
axes1 = axes; % create time-series axes on new figure.
plot_cum(handles,axes1);
% set(findobj(axes1,'Type','line','Color','r'), 'LineStyle',':'); % set sim line to dashed for print.
set(findobj(axes1,'Type','line','Color',[0 0.5 0]), 'LineWidth',2.5); % set obs line to heavier width for print.
set(gcf,'PaperOrientation','portrait', 'PaperPosition',[0.5,1.75,7.5,7.5]); % set up page format: portrait with 7.5inch centered figure.
print; % print figure.
close(gcf); % close temporary figure.
figure(h); % set plotter as active figure.

% --- Executes on button press in print_all_pushbutton.
function print_all_pushbutton_Callback(hObject, eventdata, handles)
% hObject    handle to print_all_pushbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% this executes each print push-button in succession...
print_timeseries_pushbutton_Callback(hObject, eventdata, handles);
print_simobs_pushbutton_Callback(hObject, eventdata, handles);
print_cumprob_pushbutton_Callback(hObject, eventdata, handles);


%=============== MONTHLY AVERAGE BAR-PLOT ==================
% --- Executes on button press in monthly_avg_pushbutton.
function monthly_avg_pushbutton_Callback(hObject, eventdata, handles)
% hObject    handle to monthly_avg_pushbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

if isequalwithequalnans(handles.plot_data,[NaN,NaN,NaN,NaN]) == 1 % no data loaded.
    uiwait(errordlg('No data is currently loaded - no action taken.','Error: No Data Loaded','modal'));
    return;
end

% switch upper(handles.data_type)
%     case 'FLOW'
%         data = handles.plot_data;
%     otherwise
%         % remove NaN's in observed data...
%         data = handles.plot_data;
%         temp = data(:,[1 3]);
%         temp(any(isnan(temp)'),:) = [];
%         % replace observed data with nearest-neighbor interpolation using remaining values...
%         data(:,3) = interp1(temp(:,1),temp(:,2),data(:,1),'nearest','extrap');
% end

data = handles.plot_data(:,1:3);
 
% % trim data set to common time interval for sim & obs (ie: trim leading/trailing NaN's)...
% for k = 1:size(data,1) % trim leading lines.
%     if isnan(data(k,2)) | isnan(data(k,3)) % one or both are NaN - remove row.
%         data(k,:) = [];
%     else % found first legitimate row - exit loop.
%         break;
%     end
% end
% for k = size(data,1):-1:1 % trim trailing lines.
%     if isnan(data(k,2)) | isnan(data(k,3)) % one or both are NaN - remove row.
%         data(k,:) = [];
%     else % found first legitimate row - exit loop.
%         break;
%     end
% end

% remove any NaN's in simulated data...
temp = data(:,[1 2]);
temp(any(isnan(temp)'),:) = [];
% replace simulated data with nearest-neighbor interpolation using remaining values...
data(:,2) = interp1(temp(:,1),temp(:,2),data(:,1),'nearest','extrap');

% remove any NaN's in observed data...
temp = data(:,[1 3]);
temp(any(isnan(temp)'),:) = [];
% replace observed data with nearest-neighbor interpolation using remaining values...
data(:,3) = interp1(temp(:,1),temp(:,2),data(:,1),'nearest','extrap');

% % get raw sim / obs data sets...
% if exist([handles.sim_path,handles.catcode,'.', handles.data_type]) == 2 % sim data file exists.
%     have_sim = 1;
% else
%     have_sim  = 0;
%     uiwait(errordlg(['Simulated data not loaded. No simulated bars will be visible.' ],'File Error','modal'));
% end
% if exist([handles.obs_path,handles.catcode,'.o',handles.data_type]) == 2 % obs data file exists.
%     have_obs = 1;
% else
%     have_obs  = 0;
%     uiwait(errordlg(['Observed data not loaded. No observed bars will be visible.' ],'File Error','modal'));
% end
% sim_data = handles.plot_data(:,[1,2]);
% sim_data(any(isnan(sim_data)'),:) = []; % get rid of NaN's.
% 
% obs_data = handles.plot_data(:,[1,3]);
% obs_data(any(isnan(obs_data)'),:) = []; % get rid of NaN's.
% 
% % trim data to common time interval...
% if min(obs_data(:,1)) <= min(sim_data(:,1)) % use larger minimum for start of common interval.
%     min_common = min(sim_data(:,1));
% else
%     min_common = min(obs_data(:,1));
% end
% if max(obs_data(:,1)) <= max(sim_data(:,1)) % use smaller maximum for end of common interval.
%     max_common = max(obs_data(:,1));
% else % use min of sim data for start of common interval.
%     max_common = max(sim_data(:,1));
% end
% obs_data_trim = [NaN,NaN];
% for i = 1:size(obs_data,1),
%     if (obs_data(i,1) >= min_common) & (obs_data(i,1) <= max_common) % in common interval.
%         obs_data_trim = [obs_data_trim ; obs_data(i,:)];
%     end
% end
% obs_data_trim(1,:) = [];
% sim_data_trim = [NaN,NaN];
% for i = 1:size(sim_data,1),
%     if (sim_data(i,1) >= min_common) & (sim_data(i,1) <= max_common) % in common interval.
%         sim_data_trim = [sim_data_trim ; sim_data(i,:)];
%     end
% end
% sim_data_trim(1,:) = [];

% TEST FOR PLOTTING MANIPULATED DATA...
% figure;
% hold on;
% plot(data(:,1),data(:,2),'r');
% plot(data(:,1),data(:,3),'g');
% hold off;
% datetick('x',28);

% % create data array including all days in common interval...
% data = [min_common:datenum([0 0 1]):max_common]';

all_dates = datenum(str2num(datestr(data(:,1),'yyyy')), ...
                    str2num(datestr(data(:,1),'mm')),   ...
                    ones(size(data,1),1)); % make list of all month-year pairs.
unique_dates = unique(all_dates); % make list of unique month-year pairs.
x_label = datestr(unique_dates,28); % exp: Feb1999
x_label(:,2:5) = []; % exp: F99

% find mean of sim & observed data values that match each unique month-year pair...
monthly_avg = [NaN,NaN,NaN];
for i = 1:size(unique_dates,1),
    match = (all_dates == unique_dates(i));
    match.*data(:,2);
    month_avg(i,1:3) = [unique_dates(i), ...
                        sum(match.*data(:,2))/sum(match), ...
                        sum(match.*data(:,3))/sum(match)];
end

% find overall means for entire period...
month_avg = [month_avg; ...
            [unique_dates(end)+datenum(0,0,30), mean(data(:,2)), mean(data(:,3))]];
x_label = [x_label;'TOT'];

% plot results in new window.
figure; % create separate figure window.
bar(month_avg(:,1),month_avg(:,2:3),1);
h = get(gca,'Children');
set(h(1),'FaceColor',[0 0.5 0]);
set(h(2),'FaceColor',[0.8 0 0]);
title('\bfObserved and Simulated Monthly Averages');
switch upper(handles.data_type)
    case 'FLOW'
        ylabel('AVERAGE MONTHLY DISHARGE, IN CFS');
    case 'TOTN'
        ylabel('AVERAGE MONTHLY TOTAL N, IN MG/L');
    case 'ORGN'
        ylabel('AVERAGE MONTHLY ORGANIC N, IN MG/L');
    case 'NO3X'
        ylabel('AVERAGE MONTHLY NITRATE, IN MG/L');
    case 'NH3X'
        ylabel('AVERAGE MONTHLY AMMONIA, IN MG/L');
    case 'TOTP'
        ylabel('AVERAGE MONTHLY TOTAL P, IN MG/L');
    case 'ORGP'
        ylabel('AVERAGE MONTHLY ORGANIC P, IN MG/L');
    case 'PO4X'
        ylabel('AVERAGE MONTHLY PHOSPHATE, IN MG/L');
    case 'TSSX'
        ylabel('AVERAGE MONTHLY TOT.SUSP.SEDIMENT, IN MG/L');
    case 'TOCX'
        ylabel('AVERAGE MONTHLY TOTAL ORGANIC C, IN MG/L');
    case 'DOXX'
        ylabel('AVERAGE MONTHLY DISSOLVED O, IN MG/L');
    case 'CHLA'
        ylabel('AVERAGE MONTHLY CHLOROPHYLL, IN UG/L');
    case 'WTMP'
        ylabel('AVERAGE MONTHLY WATER TEMPERATURE, IN  ^{o}C');
    otherwise
        ylabel('UNKNOWN');
end
set(gca, 'XTick',month_avg(:,1), 'XTickLabel',x_label);
axis([ month_avg(1,1)-datenum([0 0 14]), month_avg(end,1)+datenum([0 0 14]), -inf, inf ]);
switch upper(handles.data_type)
    case 'FLOW'
        legend('Simulated','Observed',2);
    otherwise
        legend('Simulated','Time-Weighted Observed',2);
end


%===================== SAVE STATS ===================
% --- Executes on button press in save_stats.
function save_stats_Callback(hObject, eventdata, handles)
% hObject    handle to save_stats (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% NOTES:
% - initializes all stats in "handles" to NaN on start-up.
% - initializes all stats in "handles" to NaN when clearing stats text-boxes.
% - save stats in data structure "handles" when computing stats.
% - write stored current stats to file when this button is pressed (ie: below).
% - get rid of below temporary error message.
uiwait(errordlg('This option is not yet available - no action taken.','Message: Unavailable Option','modal'));


%*********************** UTILITY FUNCTIONS USED IN "PLOTTER" ***********************

%============ CHECK INPUT DATES ===============
function err = check_date(date_str)
% This checks that a date is in "mm/dd/yyyy" format:
% must have 2 slashes, and mm, dd, yyyy must all be numbers.
% Day must be between 1 and 31, inclusive.
% Month must be between 1 and 12, inclusive.
% Year must be between 1950 and 2050, inclusive.
err = 0;
slashes = findstr(date_str,'/');
if  size(slashes,2) ~= 2 % doesn't have 2 "/"s.
    err = 1;
else % check numbers.
    mo = str2num(date_str(1:slashes(1)-1));
    dy = str2num(date_str(slashes(1)+1:slashes(2)-1));
    yr = str2num(date_str(slashes(2)+1:length(date_str)));    
    if sum(size(mo)) == 0 % "month" is not number.
        err = 1;
    else % "month" is number, check for validity.
        if (mo < 1) | (mo > 12) % invalid.
            err = 1;
        end
    end
    if sum(size(dy)) == 0 % "day" is not number.
        err = 1;
    else
        if (dy < 1) | (dy > 31) % invalid.
            err = 1;
        end
    end
    if sum(size(yr)) == 0 % "year" is not number.
        err = 1;
    else % "year" is number, check for validity.
        if (yr < 1950) | (yr > 2050) % invalid.
            err = 1;
        end
    end
end
if err ~= 0
    uiwait(errordlg('Date must be in mm/dd/yyyy format, using slashes and valid interger values.', ...
    'Error: Invalid Date','modal'));
end


%============= CLEAR PLOT WINDOWS ==================
function clear_plots(handles)
% this function clears all plot windows.
axes(handles.timeseries_axes); cla;
axes(handles.simobs_axes);     cla;
axes(handles.cumprob_axes);    cla;


%============ CLEAR STAT TEXT BOXES ================
function clear_stats(handles)
% this function initializes all stats and clears
% the stats from the GUI.
set(handles.n_simobs_points_text, 'String', ' ');
set(handles.min_obs_text, 'String', ' ');
set(handles.min_sim_text, 'String', ' ');
set(handles.obs_mean_text, 'String', ' ');
set(handles.sim_mean_text, 'String', ' ');
set(handles.obs_median_text, 'String', ' ');
set(handles.sim_median_text, 'String', ' ');
set(handles.max_obs_text, 'String', ' ');
set(handles.max_sim_text, 'String', ' ');
set(handles.obs_variance_text, 'String', ' ');
set(handles.sim_variance_text, 'String', ' ');
set(handles.error_variance_value_text, 'String', ' ');
set(handles.relative_bias_value_text, 'String', ' ');
set(handles.rel_std_error_value_text, 'String', ' ');
set(handles.model_eff_value_text, 'String', ' ');


%=========== GET SPECIFIED DATA ===================
function [plot_data, err] = get_data(handles)
% This checks if the specified data files exist, and reads in the values.
% Observed, Simulated, and precip data are read.
% The data is then combined and trimmed to the time period specified.

% NOTE: IF CONTINUOUS SIM DATA IS MISSING AND ONLY POINT OBSERVED
% DATA LOADED, PRECIP DATA ON DATES OTHER THAN THE OBSERVED DATES
% WILL BE LOST AND NOT DISPLAYED.

% read data...
err = 0;
have_sim  = 0;
have_obs  = 0;
have_prec = 0;
simfile  = [handles.sim_path,handles.catcode,'.', handles.data_type];
obsfile  = [handles.obs_path,handles.data_type,'\',handles.catcode,'.o',handles.data_type];
precfile = [handles.obs_path,'\prec\',handles.catcode,'.oprec'];
if exist(simfile) == 2 % sim data file exists.
    have_sim = 1;
    temp = csvread(simfile);
    % all data values are applied to mid-day of given date (noon).
    sim_data = [datenum(temp(:,1),temp(:,2),temp(:,3), ...
                12*ones(length(temp(:,1)),1),zeros(length(temp(:,1)),1),zeros(length(temp(:,1)),1)), ...
                temp(:,6)];
end
if exist(obsfile) == 2 % obs data file exists.
    have_obs = 1;
    temp = csvread(obsfile);
    % all data values are applied to mid-day of given date (noon).
    obs_data = [datenum(temp(:,1),temp(:,2),temp(:,3), ...
                12*ones(length(temp(:,1)),1),zeros(length(temp(:,1)),1),zeros(length(temp(:,1)),1)), ...
                temp(:,6)];
end
if exist(precfile) == 2 % precip data file exists.
    have_prec = 1;
    temp = csvread(precfile);
    % all data values are applied to mid-day of given date (noon).
    prec_data = [datenum(temp(:,1),temp(:,2),temp(:,3), ...
                12*ones(length(temp(:,1)),1),zeros(length(temp(:,1)),1),zeros(length(temp(:,1)),1)), ...
                temp(:,6)];
end
if (have_sim == 1) & (have_obs == 0) % don't have obs - dummy with NaN and continue.
    obs_data = [sim_data(:,1),NaN*ones(size(sim_data,1),1)];
    uiwait(errordlg(['Cannot open file: "',obsfile,'". Simulated data loaded only.' ],'File Error','modal'));
elseif (have_sim == 0) & (have_obs == 1) % don't have sim - dummy with NaN and continue.
    sim_data = [obs_data(:,1),NaN*ones(size(obs_data,1),1)];
    uiwait(errordlg(['Cannot open file: "',simfile,'". Observed data loaded only.' ],'File Error','modal'));
elseif (have_sim == 0) & (have_obs == 0) % have neither - abort.
    err = 1;
    plot_data = [NaN,NaN,NaN,NaN];
    uiwait(errordlg(['Cannot open files: "',obsfile,'", "',simfile,'". No plots or statistics generated.'],'File Error','modal'));
    return;
end
if have_prec == 0 % don't have precip data - dummy-up with NaN's.
    if size(obs_data,1) > size(sim_data,1)
        prec_data = [obs_data(:,1),NaN*ones(size(obs_data,1),1)];
    else
        prec_data = [sim_data(:,1),NaN*ones(size(sim_data,1),1)];
    end
    uiwait(errordlg(['Cannot open file: "',precfile,'". Precipitation data not available for viewing.' ],'File Error','modal'));
end

% merge data into single array, with columns: serial_time, sim_data, obs_data, precip_data.
% missing values are assigned NaN.
all_data = union(sim_data(:,1),obs_data(:,1)); % merge serial times.
all_data(:,2) = NaN*ones(size(all_data,1),1); % initialize sim
all_data(:,3) = NaN*ones(size(all_data,1),1); % initialize obs
all_data(:,4) = NaN*ones(size(all_data,1),1); % initialize precip

% find sim and obs data that matches merged time set and put in array.
[junk,data_ind,sim_ind] = intersect(all_data(:,1),sim_data(:,1));
all_data(data_ind,2) = sim_data(sim_ind,2);

[junk,data_ind,obs_ind] = intersect(all_data(:,1),obs_data(:,1));
all_data(data_ind,3) = obs_data(obs_ind,2);

[junk,data_ind,prec_ind] = intersect(all_data(:,1),prec_data(:,1));
all_data(data_ind,4) = prec_data(prec_ind,2);

% trim data to specified time interval.
plot_data = [NaN,NaN,NaN,NaN];
for i = 1:size(all_data,1)
    if (all_data(i,1) >= datenum(handles.mindate)) & (all_data(i,1) <= datenum(handles.maxdate)) % in specified range.
        plot_data = [plot_data; all_data(i,:)];
    end
end
plot_data = plot_data(2:end,:);


%============ PLOT TIME-SERIES ==================
function plot_ts(handles,axes1,axes2)
% This function plots the time-series data.
% All plots are first generated, then surpressed according to the chosen
% check-box options.

% plot obs/sim data sets...
axes(axes1); % specify axes time-series axes.
hold on;
h_sim = plot(handles.plot_data(:,1),handles.plot_data(:,2),'r'); % simulated.
switch upper(handles.data_type)
    case 'FLOW' % use continuous line for observed flow.
        h_obs = plot(handles.plot_data(:,1),handles.plot_data(:,3),'Color',[0 0.5 0]); % observed.
    otherwise % use points for other discrete data.
        h_obs = plot(handles.plot_data(:,1),handles.plot_data(:,3), ...
                'Marker','d', 'MarkerSize',5, 'MarkerEdgeColor',[0 0.5 0], 'MarkerFaceColor','none', ...
                'LineStyle','none', 'Color',[0 0.5 0]); % observed.            
end

% set various attributes on sim/obs plot...
title(['\bf',upper(handles.catcode),': ',upper(handles.data_type),' TIME-SERIES']);
switch upper(handles.data_type)
    case 'FLOW'
        ylabel('DISHARGE, IN CFS');
    case 'TOTN'
        ylabel('TOTAL N, IN MG/L');
    case 'ORGN'
        ylabel('ORGANIC N, IN MG/L');
    case 'NO3X'
        ylabel('NITRATE, IN MG/L');
    case 'NH3X'
        ylabel('AMMONIA, IN MG/L');
    case 'TOTP'
        ylabel('TOTAL P, IN MG/L');
    case 'ORGP'
        ylabel('ORGANIC P, IN MG/L');
    case 'PO4X'
        ylabel('PHOSPHATE, IN MG/L');
    case 'TSSX'
        ylabel('TOT.SUSP.SEDIMENT, IN MG/L');
    case 'TOCX'
        ylabel('TOTAL ORGANIC C, IN MG/L');
    case 'DOXX'
        ylabel('DISSOLVED O, IN MG/L');
    case 'CHLA'
        ylabel('CHLOROPHYLL, IN UG/L');
    case 'WTMP'
        ylabel('WATER TEMPERATURE, IN  ^{o}C');
    otherwise
        ylabel('UNKNOWN');
end
axis([min(handles.plot_data(:,1)), max(handles.plot_data(:,1)), -inf, inf]);
set(gca,'XTick',[min(handles.plot_data(:,1)): ...
                (max(handles.plot_data(:,1))-min(handles.plot_data(:,1)))/6: ...
                 max(handles.plot_data(:,1))]);
set(gca,'XTickLabel',datestr([min(handles.plot_data(:,1)): ...
                (max(handles.plot_data(:,1))-min(handles.plot_data(:,1)))/6: ...
                 max(handles.plot_data(:,1))],1));
axis manual;
hold off;

% over-lay precip inverted bar plot...
axes(axes2); % specify precip axes.
h_bar = bar(handles.plot_data(:,1),handles.plot_data(:,4));
set(axes2,'YAxisLocation','right', 'Ydir','reverse', 'Color','none', ...
                        'XLim',get(axes1,'XLim'),'XTick',[], 'XTickLabel',[]);
set(h_bar,'FaceColor','b', 'EdgeColor','b');
set(gca, 'TickLength',[0 0]); % this is only way I could figure out to get rid of precip ticks on left y-axis.
                              % this also gets rid of the right precip axis, too, however.
ylabel('DAILY PRECIPTATION, IN MM');
% note: precip max y-axis is set to 3 times the maximum precip value so bars only extend 1/3 of the way down the plot.
axis([min(handles.plot_data(:,1)), max(handles.plot_data(:,1)), min(handles.plot_data(:,4)), 3*max(handles.plot_data(:,4))]);
axis manual;

% adjust plots according to user preferences (check-boxes)...
if handles.hide_obs_ts == 0 % show obs data line.
    set(findobj(axes1,'Type','line','Color',[0 0.5 0]), 'Visible','on');
else % hide obs data line.
    set(findobj(axes1,'Type','line','Color',[0 0.5 0]), 'Visible','off');
end
if handles.hide_precip == 0 % show inverted precip bars.
    set(findobj(axes2,'FaceColor','b'),'Visible','on');
else % hide precip bars.
    set(findobj(axes2, 'FaceColor','b'), 'Visible','off');
end
if handles.logscale_ts ~= 0 % use log Y-scale.
    set(axes1,'Yscale','log');
else % use linear scale.
    set(axes1,'Yscale','linear');
end
legend(axes1,'Simulated','Observed',2);


%============ PLOT SIMULATED VS. OBSERVED =================
function plot_sim_obs(handles,axes1)
% This function plots the simulated vs. observed.
% The y = x ideal line and least-squares fit lines
% are added, along with some stats.

xymin = min([handles.plot_data(:,2);handles.plot_data(:,3)]);
xymax = max([handles.plot_data(:,2);handles.plot_data(:,3)]);

axes(axes1); % specify axes to use.
hold on;

plot(handles.plot_data(:,3),handles.plot_data(:,2),'ko','MarkerSize',4); % obs vs. sim dots.
% add least-square fit line with stats...
% lsline
[b, bint, r, rint, stats] = regress(handles.plot_data(:,2), [ones(size(handles.plot_data(:,3),1),1),handles.plot_data(:,3)]);
plot([xymin,xymax],[b(2)*xymin+b(1),b(2)*xymax+b(1)],'r');
% lsline; % this gives same line as above command - use to check above command.
text(xymin+0.1*(xymax-xymin), xymin+0.90*(xymax-xymin),['m = ',num2str(b(2))]) % add m stats text
text(xymin+0.1*(xymax-xymin), xymin+0.85*(xymax-xymin),['b  = ',num2str(b(1))]) % add b stats text
text(xymin+0.1*(xymax-xymin), xymin+0.80*(xymax-xymin),['r^2 = ',num2str(stats(1))]) % add r2 stats text

% add ideal y = x line...
plot([xymin xymax], [xymin xymax], 'Color',[0 0.5 0], 'LineStyle',':'); % add ideal y=x line

xlabel(['OBSERVED ',upper(handles.data_type)]);
ylabel(['SIMULATED ',upper(handles.data_type)]);
title(['\bf',upper(handles.catcode),': SIMULATED VS. OBSERVED']);
axis([xymin, xymax, xymin, xymax]);
set(gca,'XTick',get(gca,'YTick'));
set(gca,'XTickLabel',get(gca,'YTickLabel'));
axis equal;
box on;
axis manual;
hold off;

% adjust plot for user preferences (check-boxes)...
if handles.hide_regress == 0 % show regression line.
    set(findobj(axes1,'Type','line','Color','r'), 'Visible','on');
else % hide obs data line.
    set(findobj(axes1,'Type','line','Color','r'), 'Visible','off');
end
if handles.hide_yxline == 0 % plot y = x line.
    set(findobj(axes1,'Type','line','Color',[0 0.5 0]), 'Visible','on');
else % hide obs data line.
    set(findobj(axes1,'Type','line','Color',[0 0.5 0]), 'Visible','off');
end


%============= PLOT CUMULATIVE DISTRIBUTION ===================
function plot_cum(handles,axes1)
% this function plots the cumulative frequency distribution.
% NOTE: no interpolation procedure is used for point-data; raw data used.

axes(axes1);
hold on;

sim_h = cdfplot(handles.plot_data(:,2));
set(sim_h,'Color','r');

obs_h = cdfplot(handles.plot_data(:,3));
set(obs_h,'Color',[0 0.5 0]);

title(['\bf',upper(handles.catcode),': EMPIRICAL CUMULATIVE DISTRIBUTION']);
switch upper(handles.data_type)
    case 'FLOW'
        xlabel('DISHARGE, IN CFS');
    case 'TOTN'
        xlabel('TOTAL N, IN MG/L');
    case 'ORGN'
        xlabel('ORGANIC N, IN MG/L');
    case 'NO3X'
        xlabel('NITRATE, IN MG/L');
    case 'NH3X'
        xlabel('AMMONIA, IN MG/L');
    case 'TOTP'
        xlabel('TOTAL P, IN MG/L');
    case 'ORGP'
        xlabel('ORGANIC P, IN MG/L');
    case 'PO4X'
        xlabel('PHOSPHATE, IN MG/L');
    case 'TSS'
        xlabel('TOT.SUSP.SEDIMENT, IN MG/L');
    case 'TOCX'
        xlabel('TOTAL ORGANIC C, IN MG/L');
    case 'DOX'
        xlabel('DISSOLVED O, IN MG/L');
    case 'CHLA'
        xlabel('CHLOROPHYLL, IN UG/L');
    case 'WTMP'
        xlabel('WATER TEMPERATURE, IN  ^{o}C');
    otherwise
        xlabel('UNKNOWN');
end
ylabel('DISTRIBUTION');
hold off;
box on;
legend('Simulated','Observed',4);

% adjust plot for user preferences (check-boxes)...
if handles.dont_log_cum ~= 0 % use log X-scale.
    set(axes1,'Xscale','log');
else % use linear scale.
    set(axes1,'Xscale','linear');
end
if handles.hide_obs_cum == 0 % show obs line.
    set(findobj(axes1,'Type','line','Color',[0 0.5 0]), 'Visible','on');
else % hide obs line.
    set(findobj(axes1,'Type','line','Color',[0 0.5 0]), 'Visible','off');
end


%============ CALCULATE AND DISPLAY STATS ================
function calc_stats(handles)
% This function computes statistics on the current data set and
% displays them in the corresponding GUI text boxes.
% Stats are computed on points where there are both sim and obs data.

% create stats data set (ie: remove data where sim, obs, or both = NaN)...
stats_data = [NaN,NaN,NaN]; % serial_date, sim_data, obs_data.
for i = 1:size(handles.plot_data,1)
    if (isnan(handles.plot_data(i,2)) == 0) & (isnan(handles.plot_data(i,3)) == 0) % sim and obs are both numbers.
        stats_data = [stats_data; handles.plot_data(i,1:3)]; % add data.
    end
end
stats_data = stats_data(2:size(stats_data,1),:);

% % calc/display # of common data points...
n = size(stats_data,1);
set(handles.n_simobs_points_text, 'String', n);
 
% calc/display mins...
set(handles.min_sim_text, 'String', min(stats_data(:,2)));
set(handles.min_obs_text, 'String', min(stats_data(:,3)));

% calc/display means...
% sim_mean = mean(stats_data(:,2));
% obs_mean = mean(stats_data(:,3));
set(handles.sim_mean_text, 'String', mean(stats_data(:,2)));
set(handles.obs_mean_text, 'String', mean(stats_data(:,3)));

% calc/display medians...
set(handles.sim_median_text, 'String', median(stats_data(:,2)));
set(handles.obs_median_text, 'String', median(stats_data(:,3)));

% calc/display maxes...
set(handles.max_sim_text, 'String', max(stats_data(:,2)));
set(handles.max_obs_text, 'String', max(stats_data(:,3)));

% calc/display variance...
% (the following manual calculations produces same results as built in VAR function.)
% sim_var = dot(stats_data(:,2) - sim_mean, stats_data(:,2) - sim_mean)/(n-1);
% obs_var = dot(stats_data(:,3) - obs_mean, stats_data(:,3) - obs_mean)/(n-1);
set(handles.sim_variance_text, 'String', var(stats_data(:,2)));
set(handles.obs_variance_text, 'String', var(stats_data(:,3)));

% calc/display error variance...
err_var = dot(stats_data(:,2)-stats_data(:,3),stats_data(:,2)-stats_data(:,3))/(n-1);
set(handles.error_variance_value_text, 'String', err_var);

% calc/display relative bias...
rel_bias = sum(stats_data(:,2)-stats_data(:,3))/n/osmean(stats_data):,3);
set(handles.relative_bias_value_text, 'String', rel_bias);

% calc/display rel std err...
rel_std_err = err_var/var(stats_data(:,3));
set(handles.rel_std_error_value_text, 'String', rel_std_err);

% calc/display model efficiency...
set(handles.model_eff_value_text, 'String', 1-rel_std_err);
